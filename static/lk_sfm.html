<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Lukas-Kanade Tracking">
        <title>LKTracker</title>
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    </head>
    <body>
        <style> 
            body {
                margin: 0px;
                overflow: hidden;
                position: absolute;
            }
        </style>

        <!-- < THREE> -->
        <script src="js/Three.js"></script>
        <script src="js/parser.js"></script>
        <script src="js/rainbowvis.js"></script>
        <script src="js/OrbitControls.js"></script>

        <!-- < JSFEAT > -->
        <script type="text/javascript" src="js/jsfeat.js"></script>
        
        <!-- < BUNDLE ADJUSTMENT > -->
        <script src="js/numeric-1.2.6.js"></script>

        <!-- < CUSTOM > -->
        <script type="text/javascript" src="js/fullscreen_compatibility.js"></script>

        <script type="text/javascript">

        /* 
        ---=== Libs from: ===---
        JSFeat - http://inspirit.github.io/jsfeat/#opticalflowlk
        VisualSFM - http://ccwu.me/vsfm/

        ---==================---
        */

        var URL_params = getURLparams();
        if (!URL_params.maxWidth && !URL_params.sc) {
            URL_params.maxWidth = 640;
        }

        // vARS FOR DISPLAYING VIDEO FEED
        var fs = fullscreen_compatibility;
        var size, container, canvas, ctx,  s_canvas, s_ctx, video, info;
        fs.createVideoCanvas({camera_direction:"environment", sc:URL_params.sc, maxWidth: URL_params.maxWidth, 

            callback:function() { //callback when complete

                var e = fs.get_elements();
                video = e.video;
                container = e.container;
                ctx = e.ctx;
                canvas = e.canvas;
                s_ctx = e.s_ctx;
                s_canvas = e.s_canvas;
                size = fs.get_size()

                console.log("fs initialized... size:");
                console.log(size);
                init();

            }

        });

        // UTIL VARS
        var lev_colors;
        var lev_colors_rgb;
        var fps = 0;
        var fps_three = 0;

        // THREE JS VARS
        var scene, camera, renderer;
        var arrows, model, raycaster, raycaster_default_threshold;

        var mouse = new THREE.Vector2();

        var cameras = []; // from parser.js

        // TICK VARS (EVERY FRAME)
        var auto_bundle = false;
        var server_refreshrate = 20 * 1000; // 20s
        var server_refreshevent = false;
        var server_autorefresh = false;
        function server_refresh() {
            if (server_autorefresh && !server_refreshevent) {

                server_refreshevent = true;
                setTimeout(function() {
                    if (server_autorefresh) {
                        takeScreenShot();
                        server_refreshevent = false;
                        //server_refresh();
                    }

                }, server_refreshrate);

            }
        }

        function onMouseMove( event ) {

            // calculate mouse position in normalized device coordinates
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;     

        }
        window.addEventListener( 'mousemove', onMouseMove, false );

        function init() {
            
            // ---=== GUI ===---

            var btn_padding = 10;
            var btn_spacing = 45;
            var btn_top = 30;

            var btn = document.createElement( 'button');
            btn.innerHTML = "FAST";
            btn.style.cssText = 'position:absolute;margin-left:10px;margin-top:' + btn_top + 'px;padding:' + btn_padding + 'px;z-index:10;white-space:nowrap';
            container.appendChild( btn );
            btn.addEventListener( "click" , 
                function() {

                    console.log("starting with " + point_count + " points : ");
                    train_pattern();
                    print_pointlist();
                    var id_start = 0;
                    if (point_count>0) id_start = point_id[point_count-1]-point_count+1;

                    for(lev = 0; lev < options_orb.num_train_levels; ++lev) {
                        for(i = 0; i < corners_num[lev]; ++i) {
                            curr_xy[point_count<<1] = pattern_corners[lev][i].x;
                            curr_xy[(point_count<<1)+1] = pattern_corners[lev][i].y;
                            point_id[point_count] = point_count + id_start;
                            if (point_count>=99) {console.log("total point count: " + point_count + " (maxed out early)"); print_pointlist();raycast_points(true);return;}
                            point_count++;
                        }
                    }
                    console.log("total point count: " + point_count);
                    print_pointlist();
                    if (model.children.length) raycast_points(true);
                }
            );
            setInterval( function () {
                if (point_count > 0) {
                    if (points_3d.length>0) btn.innerHTML = "FAST (" + point_count + ", " + points_3d.length + ")";
                    else btn.innerHTML = "FAST (" + point_count + ")";
                } else  btn.innerHTML = "FAST";
            }, 250);


            var btn2 = document.createElement( 'button');
            btn2.innerHTML = "FULL"; // fullscreen
            btn2.style.cssText = 'position:absolute;margin-left:10px;margin-top:' + (btn_top + btn_spacing) + 'px;padding:' + btn_padding + 'px;z-index:10;';
            container.appendChild( btn2 );
            btn2.addEventListener( "click" , function() { fs.requestFullscreen(container);} );

            var btn3 = document.createElement( 'button');
            btn3.innerHTML = "PHOTO"; // take a screenshot & send to server
            btn3.style.cssText = 'position:absolute;margin-left:10px;margin-top:' + (btn_top + 2 * btn_spacing) + 'px;padding:' + btn_padding + 'px;z-index:10;';
            container.appendChild( btn3 );
            btn3.addEventListener( "click" ,takeScreenShot );

            var btn4 = document.createElement( 'button');
            btn4.innerHTML = "LOAD"; // take a screenshot & send to server
            btn4.style.cssText = 'position:absolute;margin-left:10px;margin-top:' + (btn_top + 3 * btn_spacing) + 'px;padding:' + btn_padding + 'px;z-index:10;';
            container.appendChild( btn4 );
            btn4.addEventListener( "click" , function () {getNVM()} );

            var btn5 = document.createElement( 'button');
            btn5.innerHTML = "EDIT"; // take a screenshot & send to server
            btn5.style.cssText = 'position:absolute;margin-left:10px;margin-top:' + (btn_top + 4 * btn_spacing) + 'px;padding:' + btn_padding + 'px;z-index:10;';
            container.appendChild( btn5 );
            btn5.addEventListener( "click" , function() {
                if (controls.enabled) {
                    controls.enabled = false;
                    renderer.domElement.addEventListener( 'mousedown', mouseDownCreateObject, false );
                    btn5.innerHTML = "STOP EDITING";
                } else {
                    renderer.domElement.removeEventListener( 'mousedown', mouseDownCreateObject, false );
                    controls.enabled = true;
                    btn5.innerHTML = "EDIT";
                }
            });

            info = document.createElement( 'p' );
            info.style.cssText = 'position:absolute;margin-left:80px;margin-top:10px;z-index:11;width:100px';
            container.appendChild(info);

            resize_callback = function() {
                // change circle size (on canvas resize)
                options_lk.circle_radius = Math.max(1,Math.floor(size.w/250));

                info.innerHTML = "vid: " + size.vw + ", " + size.vh + "<br>" + 
                                 "can: " + size.w + ", " + size.h + "<br>" + 
                                 "s_c: " + s_canvas.width + ", " + s_canvas.height  + "<br>" ;

                renderer.setSize(window.innerWidth, window.innerHeight);

                // update the camera
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

            }
            fs.set_resizecallback( resize_callback );

            var fps_info = document.createElement( 'p' );
            fps_info.style.cssText = 'position:absolute;margin-left:8px;margin-top:5px;z-index:11;width:100px';
            container.appendChild(fps_info);
            var fps_refreshrate = 500;
            setInterval (function() {
                fps_info.innerHTML = (fps*1000/fps_refreshrate) + "/" + (fps_three*1000/fps_refreshrate);
                fps = 0;
                fps_three = 0;
            }, fps_refreshrate);

            // ---=== THREEJS INIT ===---

            // SCENE
            scene = new THREE.Scene();
            arrows = new THREE.Object3D();
            scene.add(arrows);
            model = new THREE.Object3D();
            scene.add(model);

            // CAMERA
            var SCREEN_WIDTH = window.innerWidth,
                SCREEN_HEIGHT = window.innerHeight;
            var VIEW_ANGLE = 45,
                ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT,
                NEAR = 0.1,
                FAR = 2000000;

            camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
            scene.add(camera);

            var cameraOffset = {
                x: 0,
                y: 150,
                z: 400
            };

            camera.position.set(cameraOffset.x, cameraOffset.y, cameraOffset.z);
            camera.lookAt(scene.position);

            raycaster = new THREE.Raycaster();
            raycaster.params.PointCloud.threshold = raycaster_default_threshold = 9;


            // RENDERER
            var check_webgl = function() {
                try {
                    return !!window.WebGLRenderingContext && !!document.createElement('canvas').getContext('experimental-webgl');
                } catch (e) {
                    return false;
                }
            }
            if (check_webgl())
                renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true
                });
            else
                renderer = new THREE.CanvasRenderer({
                    transparent: true
                });
            renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.zIndex = 8; // below buttons, above canvii
            //renderer.setClearColor( 0xffffff, 1 );
            container.appendChild(renderer.domElement);

            // CONTROLS
            controls = new THREE.OrbitControls( camera, renderer.domElement );


            // LIGHT
            var light = new THREE.PointLight(0xffffff);
            light.position.set(100, 250, 100);
            scene.add(light);

            ///////////////////
            // AXES & ARROWS //
            ///////////////////
            axes = new THREE.Object3D();
            var dir = new THREE.Vector3(10, 0, 0);
            var origin = new THREE.Vector3(0, 0, 0);
            var length = 100;
            var hex = 0xff0000;
            var arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex);
            axes.add(arrowHelper);

            var dir = new THREE.Vector3(0, 10, 0);
            var hex = 0x00ff00;
            var arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex);
            axes.add(arrowHelper);

            var dir = new THREE.Vector3(0, 0, 10);
            var hex = 0x0000ff;
            var arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex);
            axes.add(arrowHelper);
            scene.add(axes);




            // ---=== CANVAS DATA ===---

            img_u8 = new jsfeat.matrix_t(size.vw, size.vh, jsfeat.U8_t | jsfeat.C1_t);
            // after blur
            img_u8_smooth = new jsfeat.matrix_t(size.vw, size.vh, jsfeat.U8_t | jsfeat.C1_t);


            // ---=== LKT ===---

            curr_img_pyr = new jsfeat.pyramid_t(3);
            prev_img_pyr = new jsfeat.pyramid_t(3);
            curr_img_pyr.allocate(size.vw, size.vh, jsfeat.U8_t|jsfeat.C1_t);
            prev_img_pyr.allocate(size.vw, size.vh, jsfeat.U8_t|jsfeat.C1_t);

            point_count = 0;
            point_status = new Uint8Array(100);
            prev_xy = new Float32Array(100*2);
            curr_xy = new Float32Array(100*2);
            point_id = new Uint16Array(100);

            lev_colors = ['#FFFFFF','#FF0000','#00FF00','#0000FF','#FFFF00','#222222'];
            lev_colors_rgb = [];
            lev_colors.forEach(function(c, idx) {
                lev_colors_rgb[idx] = hexToRgb(c);
            });
            console.log(lev_colors_rgb);

            function hexToRgb(hex) {
                var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16)/255,
                    g: parseInt(result[2], 16)/255,
                    b: parseInt(result[3], 16)/255
                } : null;
            }

            // we wll limit to 500 strongest points
            pattern_corners = [];
            

            resize_callback()
            tick();
            animate();
        }

        var latestCamera = false;
        document.addEventListener("keypress", function(e) {
            if (e.which == 67 || e.which == 99)  {
                if (latestCamera) setCamera(latestCamera);
                else {
                    console.log("no latestCamera");
                    if (cameras.length>0) setCamera(cameras[cameras.length-1]);
                }
            } else if (e.which == 114 || e.which == 82)  { // R
                raycaster.params.PointCloud.threshold++;
                console.log("new raycaster threshold = " + raycaster.params.PointCloud.threshold);
            }  else if (e.which == 66 || e.which == 98)  { // B
                auto_bundle = !auto_bundle;
            }  else if (e.which == 83 || e.which == 115)  { // S 
                raycast_points(true)
            }  else if (e.which == 116 || e.which == 84)  { // T
                raycast_points();
                
            }  else if (e.which == 101)  { // E
                if (controls.enabled) {
                    controls.enabled = false;
                    renderer.domElement.addEventListener( 'mousedown', mouseDownCreateObject, false );
                } else {
                    renderer.domElement.removeEventListener( 'mousedown', mouseDownCreateObject, false );
                    controls.enabled = true;
                }
            } else {
                console.log(e.which + " pressed");
            }
        });


        function mouseDownCreateObject() {
            if (model.children.length > 0 ) {
                raycaster.setFromCamera( mouse, camera );   
                var intersections = raycaster.intersectObjects( model.children);

                var intersect_pos = new THREE.Vector3(0,0,0);
                var numGood = 0;
                intersections.forEach(function(intersection, idx) {
                    intersect_pos.add(intersection.point);
                    numGood++;
                });
                if (numGood>0) {
                    intersect_pos.divideScalar(numGood);
                    var geometry = new THREE.SphereGeometry( Math.random()* 5, 32, 32 );
                    var material = new THREE.MeshBasicMaterial( {color: Math.random()*0xFFFFFF<<0} );
                    var sphere = new THREE.Mesh( geometry, material );
                    sphere.position.copy(intersect_pos);
                    scene.add( sphere );

                    if (Math.random() > 0.5) {
                        // var msgs = 'hi/label here/text/a very long description/1/2/3/4/5/info'.split('/')
                        // var msg = msgs[Math.floor(Math.random()*msgs.length)];
                        // var spritey = new THREE.TextGeometry(msg)
                        // makeTextSprite( " " + msg + " ", { fontsize: 32, backgroundColor: {r:255, g:100, b:100, a:1} } );
                        var s = 100;
                        var geometry = new THREE.SphereGeometry( Math.random()* 5, 32, 32 );
                        var sphere2 = new THREE.Mesh( geometry, material );
                        sphere2.position.copy(intersect_pos).add(new THREE.Vector3(Math.random() * s,Math.random() * s,Math.random() * s));
                        scene.add( sphere2 );
                    }   
                } else {
                    console.log("didn't click on anything")
                }
                console.log(intersect_pos);

            } else {
                console.log("no pointcloud, no adding!");
            }
        }
        function tick() {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                fps++;
                fs.drawStep();
                fs.s_drawStep();
                
                var imageData = s_ctx.getImageData(0,0, size.vw, size.vh).data;
                
                jsfeat.imgproc.grayscale(imageData, size.vw, size.vh, img_u8);
                jsfeat.imgproc.gaussian_blur(img_u8, img_u8_smooth, options_orb.blur_size|0);
                
                // swap flow data
                var _pt_xy = prev_xy;
                prev_xy = curr_xy;
                curr_xy = _pt_xy;
                var _pyr = prev_img_pyr;
                prev_img_pyr = curr_img_pyr;
                curr_img_pyr = _pyr;
                curr_img_pyr.build(img_u8, false);

                var prev_point_count = point_count;
                jsfeat.optical_flow_lk.track(prev_img_pyr, curr_img_pyr, prev_xy, curr_xy, point_count, options_lk.win_size|0, options_lk.max_iterations|0, point_status, options_lk.epsilon, options_lk.min_eigen);

                // scale for circles
                scale_w = size.w/size.vw;
                scale_h = size.h/size.vh;
                prune_oflow_points(ctx);
                if (prev_point_count != point_count && 0) {
                    console.log(prev_point_count,point_count);
                    console.log(point_status);  
                    print_pointlist(); 
                }
                
                draw_lines();

                if (auto_bundle) bundle_adjustment();
            }
            fs.requestAnimationFrame(tick);

        }


        function animate() {
            fs.requestAnimationFrame(animate);
            fps_three++;
            renderer.render(scene, camera);
        }

        function bundle_adjustment(verbose) {

            // generate a list of points to minimize distance between
            var ptsfrom = [];
            var i = point_count-1, j = points_3d.length-1;
            if (verbose) console.log(point_id, points_3d);
            if (verbose) console.log(i, j);
            if (i!=0 && j!=0) while(i+1 && j+1) {
                var id1 = point_id[i];
                var id2 = points_3d[j].id;
                if (verbose) console.log(id1, id2, i, j);
                if (id1 > id2) i--;
                else if (id1 < id2) j--;
                else if (id1 == id2) {
                    ptsfrom.push({
                        x:points_3d[j].pos.x , y:points_3d[j].pos.y , z:points_3d[j].pos.z,
                        x1: (curr_xy[i<<1]   * scale_w + size.offsetW) / (0.5*window.innerWidth) - 1, // transform to coordinates of camera.project(xyz) to save cpu
                        y1: -(curr_xy[(i<<1)+1] * scale_h + size.offsetH) / (0.5*window.innerHeight) + 1,
                        e:0,use:true
                    }); 
                    i--; 
                    j--;
                }
            }
            if (verbose) console.log(ptsfrom);

            var bestfoundcam = camera.clone();
            var initial_error = bundle_error(bestfoundcam, ptsfrom, true);
            if (verbose) console.log("beginning error : "  + initial_error);
            if (isNaN(initial_error)) {console.log("error is NaN so aborting using " + point_count + " points and " + points_3d.length + " Vector3's" ); auto_bundle=false; return;}
            var sc_p = 1; // position movement multiplier
            var num_f = 0; // number of f() evaluations
            var testcams = []; // all f camera pos's
            var make_camera = function(a,b,c,d,e,f) {
                var testcam = camera.clone();
                testcam.quaternion.multiply( new THREE.Quaternion().setFromEuler(new THREE.Euler(a,b,c, 'XYZ')) );
                testcam.position.add(new THREE.Vector3(d*sc_p,e*sc_p,f*sc_p));//.add(offset);
                testcam.updateMatrixWorld(true);
                return testcam;
            }

            var f = function(v) {
                var testcam = make_camera(v[0], v[1], v[2], v[3],v[4],v[5]);
                testcam.i = num_f;
                var err = bundle_error(testcam,ptsfrom,false);
                testcam.err = err;
                num_f++;
                testcams.push(testcam); 
                return err; 
            }

            var starting_guess = [0,0,0,0,0,0];
            var solution = numeric.uncmin(f,starting_guess,1e-8,undefined,undefined,undefined /*cb*/);

            var v = solution.solution;
            var final_cam = make_camera(v[0], v[1], v[2], v[3],v[4],v[5]);
            if (verbose) console.log(v);
            var final_err = bundle_error(final_cam,ptsfrom,true);
            if (verbose) console.log("final_err = " + final_err);

            // copy the final camera
            camera.quaternion.copy(final_cam.quaternion);
            camera.position.copy(final_cam.position);
            camera.updateMatrixWorld(true);
        }

        function bundle_error(cam, pts, dontremove) {
            var error = 0;
            var num_pts = 0;
            var max_error=0;
            var max_error_index;
            for (var i=0; i < pts.length; i++) {
                var p = new THREE.Vector3(pts[i].x,pts[i].y,pts[i].z);
                var v = p.project(cam); // get 2d screen points
                //if (bundle_verbose && i==0) console.log(v);
                var e = Math.pow(v.x-pts[i].x1,2) + Math.pow(v.y-pts[i].y1,2);
                pts[i].e += e;
                if (!pts[i].use) continue;
                error+= e;
                num_pts++;
                if (e>max_error) {
                    max_error = e;
                    max_error_index = i;
                }
            }

            error /= num_pts;
            if (max_error>error*10 && !dontremove) {
                console.log("splicing point ", max_error_index, ", error was ", max_error, " > ", error, " * 10   ");//, pts[max_error_index].realdist>10 ? " a good call" : " a bad call!!" );
                pts[max_error_index].use = false;
            }
            return error;
        }



        var points_3d = [];
        function raycast_points(serious) {

            if (serious) {
                raycaster.params.PointCloud.threshold = 9;
                setCamera(cameras[cameras.length-1]);
            }
            var n = point_count;
            var j, intersections, pos = new THREE.Vector2();
            if (!model.children[0].geometry.colors) {console.log("no pointcloud.. ");return;}
            var colorArray = model.children[0].geometry.colors;
            //console.log(colorArray);
            for(var i = 0; i < n; ++i) {                    
                if(point_status[i] == 1) {
                    var j=i<<1;
                    pos.x =  ((curr_xy[j]  /size.vw)-0.5)*(1-size.offsetW*2/window.innerWidth )*2;
                    pos.y = -((curr_xy[j+1]/size.vh)-0.5)*(1-size.offsetH*2/window.innerHeight)*2;
                    //console.log(curr_xy[j],pos.x,pos.y,curr_xy[j+1]);
                    draw_circle(ctx, (pos.x+1)*size.vw/2, (-pos.y*size.vh+1)/2, lev_colors[point_id[i]%6]);

                    raycaster.setFromCamera( pos, camera );   
                    var intersections = raycaster.intersectObjects( model.children);
                    if (intersections.length>0) {
                        if (serious) {
                            var intersect_pos = new THREE.Vector3(0,0,0);
                            var numGood = 0;
                            intersections.forEach(function(intersection, idx) {
                                intersect_pos.add(intersection.point);
                                numGood++;
                            });
                            if (numGood>0) {
                                intersect_pos.divideScalar(numGood);
                                points_3d.push({id:point_id[i],pos:intersect_pos});//model.children[0].geometry.vertices[intersections[0].index]});//intersect_pos});
                            }
                            //console.log(intersect_pos);

                        } 
                        var minDist = 50;
                        var minIdx = -1;
                        var col = lev_colors_rgb[point_id[i]%6];//lev_colors[k % 6]
                        intersections.forEach(function(i, idx) {
                            minIdx = idx;
                            colorArray[intersections[idx].index].r = col.r;
                            colorArray[intersections[idx].index].b = col.b;
                            colorArray[intersections[idx].index].g = col.g;
                        });
                        
                    }
                } 
            }
            //console.log(points_3d)
            //points_3d.forEach(function(e){console.log(e.pos)});
            model.children[0].geometry.colorsNeedUpdate = true;
        }

        function draw_lines() {
            var j = 0;
            var x1, y1, x2, y2, v = new THREE.Vector3();
            var numDrawn = 0;
            var ray_scale = {
                w: 0.5*window.innerWidth,
                h: 0.5*window.innerHeight
            };
            for(var i = 0; i < points_3d.length; i++) {
                j = 0;
                while (1) {
                    if ( j >= point_count || point_id[j] == points_3d[i].id) break;
                    if ( point_id[j] > points_3d[i].id ) { j=9999; break; }
                    j++;
                }
                if ((j>=point_count)) {
                    console.log("not found " + i );
                    points_3d.splice(i,1); 
                    i--;
                    continue;
                }
                numDrawn++;
                x1 = curr_xy[j<<1] * scale_w + size.offsetW;
                y1 = curr_xy[(j<<1)+1] * scale_h + size.offsetH;
                v.copy(points_3d[i].pos);
                v.project(camera);
                // x2 = ((v.x+1)*0.5)*(size.w)+size.offsetW;
                // y2 = ((-v.y+1)*0.5)*(size.h)+size.offsetH;
                x2 = (v.x+1)*ray_scale.w;
                y2 = (-v.y+1)*ray_scale.h;

                ctx.strokeStyle = lev_colors[point_id[j]%6];
                ctx.beginPath();
                ctx.moveTo(x1,y1);
                ctx.lineTo(x2,y2);
                ctx.stroke();
            }
            if (numDrawn>0 && 0) console.log("numDrawn" + numDrawn);
        }


        function prune_oflow_points(ctx) {
            // remove untracked points and resize point array 
            var n = point_count;
            var i=0,j=0;
            var col;// = "#FF0000";
            for(; i < n; ++i) {                    
                if(point_status[i] == 1) {
                    if(j < i) {
                        curr_xy[j<<1] = curr_xy[i<<1];
                        curr_xy[(j<<1)+1] = curr_xy[(i<<1)+1];
                        point_id[j] = point_id[i];
                    } 
                    col = lev_colors[point_id[i]%6];//lev_colors[k % 6]
                    draw_circle(ctx, curr_xy[i<<1], curr_xy[(i<<1)+1], col);
                    ++j;
                } 
            }
            point_count = j;
        }
        function draw_circle(ctx, x, y, col) {
            ctx.fillStyle= col;
            ctx.beginPath();
            ctx.arc(x * scale_w + size.offsetW, y * scale_h + size.offsetH, options_lk.circle_radius, 0, Math.PI*2, true); 
            ctx.closePath();
            ctx.fill();
        }
        function print_pointlist() {
            console.log(point_id.subarray(0,point_count));
        }

        var img_u8, img_u8_smooth, corners_num = [];
        var pattern_corners;
        var curr_img_pyr, prev_img_pyr, point_count, point_status, prev_xy, curr_xy, point_id;

        // scale from jsfeat coordinates to display coordinates
        var scale_w, scale_h;

        var options_orb = {
            blur_size:5,
            lap_thres:30,
            eigen_thres:25,
            match_threshold:48,
            num_train_levels:1,
            max_per_level:100
        }
        var options_lk = {
            win_size:20,
            max_iterations:30,
            epsilon:0.01,
            min_eigen:0.001,
            circle_radius:4
        }

        function train_pattern() {

            // var imageData = s_ctx.getImageData(0,0, size.vw, size.vh).data;
            
            // jsfeat.imgproc.grayscale(imageData, size.vw, size.vh, img_u8);
            // jsfeat.imgproc.gaussian_blur(img_u8, img_u8_smooth, options_orb.blur_size|0);
            

            var lev=0;
            var sc = 1.0;
            var max_pattern_size = 512;
            var max_per_level = options_orb.max_per_level;
            var sc_inc = Math.sqrt(2.0); // magic number ;)
            var lev0_img = new jsfeat.matrix_t(img_u8.cols, img_u8.rows, jsfeat.U8_t | jsfeat.C1_t);
            var lev_img = new jsfeat.matrix_t(img_u8.cols, img_u8.rows, jsfeat.U8_t | jsfeat.C1_t);
            var new_width=0, new_height=0;
            var lev_corners, lev_descr;

            var sc0 = Math.min(max_pattern_size/img_u8.cols, max_pattern_size/img_u8.rows);
            new_width = (img_u8.cols*sc0)|0;
            new_height = (img_u8.rows*sc0)|0;

            jsfeat.imgproc.resample(img_u8, lev0_img, new_width, new_height);

            for(lev=0; lev < options_orb.num_train_levels; ++lev) {
                pattern_corners[lev] = [];
                lev_corners = pattern_corners[lev];

                // preallocate corners array
                var i = (new_width*new_height) >> lev;
                while(--i >= 0) {
                    lev_corners[i] = new jsfeat.keypoint_t(0,0,0,0,-1);
                }

            }

            // lets do multiple scale levels
            // we can use Canvas e.ctx draw method for faster resize 
            // but its nice to demonstrate that you can do everything with jsfeat
            for(lev = 0; lev < options_orb.num_train_levels; ++lev) {
                lev_corners = pattern_corners[lev];

                new_width = (lev0_img.cols*sc)|0;
                new_height = (lev0_img.rows*sc)|0;
                if (lev!=0) {
                    jsfeat.imgproc.resample(lev0_img, lev_img, new_width, new_height);
                    jsfeat.imgproc.gaussian_blur(lev_img, lev_img, options_orb.blur_size|0);
                } else {
                    jsfeat.imgproc.gaussian_blur(lev0_img, lev_img, options_orb.blur_size|0); // this is more robust
                }
                corners_num[lev] = detect_keypoints(lev_img, lev_corners, max_per_level);

                // fix the coordinates due to scale level
                for(var i = 0; i < corners_num[lev]; ++i) {
                    lev_corners[i].x *= 1./(sc*sc0);
                    lev_corners[i].y *= 1./(sc*sc0);
                }

                console.log("train " + lev_img.cols + "x" + lev_img.rows + " points: " + corners_num[lev]);

                sc /= sc_inc;
            }
        }

        // UTILITIES

        function detect_keypoints(img, corners, max_allowed) {

            

            jsfeat.yape06.laplacian_threshold = options_orb.lap_thres|0;
            jsfeat.yape06.min_eigen_value_threshold = options_orb.eigen_thres|0;

            // detect features
            //var count = jsfeat.yape06.detect(img, corners, 17);
            var count = jsfeat.fast_corners.detect(img, corners, 7); // last arg is border (default 3)
            console.log(count)
            // sort by score and reduce the count if needed
            if(count > max_allowed) {
                jsfeat.math.qsort(corners, 0, count-1, function(a,b){return (b.score<a.score);});
                count = max_allowed;
            }


            return count;
        }

        function getURLparams() {
            // This function is anonymous, is executed immediately and 
            // the return value is assigned to QueryString!
            var query_string = {};
            var query = window.location.search.substring(1);
            var vars = query.split("&");
            for (var i=0;i<vars.length;i++) {
                var pair = vars[i].split("=");
                if (typeof query_string[pair[0]] === "undefined") { // If first entry with this name
                    query_string[pair[0]] = decodeURIComponent(pair[1]);
                } else if (typeof query_string[pair[0]] === "string") { // If second entry with this name
                    var arr = [ query_string[pair[0]],decodeURIComponent(pair[1]) ];
                    query_string[pair[0]] = arr;
                } else { // If third or later entry with this name
                    query_string[pair[0]].push(decodeURIComponent(pair[1]));
                }
            } 
            return query_string;
        }

        // ---=== SERVER IMAGE SENDING/RECIEVING .NVM's ===---


        var uploads = [];

        function takeScreenShot() {
            // s_ctx.drawImage(video,0,0);
            var dataURL = s_canvas.toDataURL("image/jpeg",1.0);
            sendImage(dataURL);
        }


        function sendImage(dataURL) {
             
            console.log(uploads);

            if (window.XMLHttpRequest) {
                xmlhttp = new XMLHttpRequest();
            }

            var uploadid = uploads.length;
            uploads[uploadid] = {
                req: xmlhttp,
                percent: 0,
                size: dataURL.length,
                done: false
            };

            var readyState = function(uploadid, xmlhttp) {
                return function() {
                    if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
                        info.innerHTML = "xmlhttp.readyState = " + xmlhttp.readyState + ", xmlhttp.status = " + xmlhttp.status + ", responseText = " + xmlhttp.responseText;
                        var res = JSON.parse(xmlhttp.responseText);
                        if (res.success) {
                            info.innerHTML += "<br> SUCCESS!";
                            if (res.name) {
                                info.innerHTML += "<br> name : " + res.name;

                                var callback = function(success, found, result) {
                                    // console.log("name : " + name + " = res.name? : " + res.name);
                                    if (success && found && result.used == 3) {
                                        console.log("success!!!!" + result);
                                        getNVM(res.name, res.name);
                                    } else {
                                        setTimeout(function() {
                                            getJPG(res.name, callback);
                                        }, 250); // poll the server until the JPG has been processed
                                    }
                                
                                } 
                                
                                getJPG(res.name, callback(res.name));
                            }

                        }
                        else {info.innerHTML += "<br> NO SUCCESS :(";}
                        uploads[uploadid].done = true;
                    }
                }
            }
            xmlhttp.onreadystatechange = readyState(uploadid, xmlhttp); // curry the functions so they access the correct upload[uploadid]'s'
            var progress = function(uploadid) {
                return function(evt) {
                    if (evt.loaded) {
                        var percentComplete = Math.min(100, (evt.loaded / evt.total) * 100);
                        uploads[uploadid].percent = percentComplete;
                        //console.log(percentComplete);
                    }
                }
            }
            xmlhttp.onprogress = progress(uploadid); 
            xmlhttp.open("POST", "../dataURL", true);
            xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            xmlhttp.send(dataURL);
        }


        function getNVM(name, camera_name) {
            if (window.XMLHttpRequest) {
                xmlhttp = new XMLHttpRequest();
            } else {console.log("XMLHttpRequest ERROR"); return;}
            var ready = function(name, camera_name) {
                console.log("getNVM, function,  name = " + name + ", camera_name = " + camera_name)

                return function() {
                    if (xmlhttp.readyState==4 && xmlhttp.status==200) {
                        //info.innerHTML=xmlhttp.responseText;
                        if (xmlhttp.responseText.slice(0,6)=="NVM_V3") {
                            console.log("getNVM, name = " + name + ", camera_name = " + camera_name)
                            console.log("recieved (valid) NVM with camera! ");
                            arrows.children = [];
                            model.children = [];
                            cameras = readFile(xmlhttp.responseText, camera_name);
                        } else {
                            console.log("getNVM sent " + name);
                            console.log("NVM    server responded " + xmlhttp.responseText);
                        }

                    }
                }
            }
            xmlhttp.onreadystatechange = ready(name, camera_name);

            var path = "../latestNVM.nvm";
            if (name) {
                path = "../model?cam=" + name;
            } 
            console.log(path);
            xmlhttp.open("GET",path,true);
            xmlhttp.send();
        }

        function getJPG(name, callback) {
            if (window.XMLHttpRequest) {
                xmlhttp = new XMLHttpRequest();
            }
            xmlhttp.onreadystatechange=ready(name);
            function ready(name) {
                return function() {
                    if (xmlhttp.readyState==4 && xmlhttp.status==200) {
                        //info.innerHTML=xmlhttp.responseText;
                        var res = JSON.parse(xmlhttp.responseText);
                        if (callback) {
                            callback(res.success, res.found, res.result);
                        }
                        if (res.success) {
                            if (res.found) {
                                //console.log("getJPG returned " + JSON.stringify(res.result));
                                //console.log("getJPG " + name + " has used  = " + res.result.used );
                            } else {
                                console.log("getJPG " + name + " was not found ");
                            }
                        } else {
                            console.log("getJPG failed " + res);
                        }
                        server_autorefresh = true; 
                        server_refresh();
                    }
                }
            }
            var path = "../jpgs_lookup?jpg=" + name;
            
            xmlhttp.open("GET",path,true);
            xmlhttp.send();
        }

        </script>
    </body>
</html>