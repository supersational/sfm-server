<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Lukas-Kanade Tracking">
        <title>LKTracker</title>
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    </head>
    <body>
        <style> 
            body {
                margin: 0px;
                overflow: hidden;
                position: absolute;
            }
        </style>

        <!-- < THREE> -->
        <script src="js/Three.js"></script>
        <script src="js/parser.js"></script>
        <script src="js/rainbowvis.js"></script>
        <script src="js/OrbitControls.js"></script>

        <!-- < JSFEAT > -->
        <script type="text/javascript" src="js/jsfeat.js"></script>
        
        <!-- < CUSTOM > -->
        <script type="text/javascript" src="js/fullscreen_compatibility.js"></script>

        <script type="text/javascript">

        /* 
        ---=== Libs from: ===---
        JSFeat - http://inspirit.github.io/jsfeat/#opticalflowlk
        VisualSFM - http://ccwu.me/vsfm/

        ---==================---
        */

        var URL_params = getURLparams();
        if (!URL_params.maxWidth && !URL_params.sc) {
            URL_params.maxWidth = 640;
        }


        var fs = fullscreen_compatibility;
        var size, container, canvas, ctx,  s_canvas, s_ctx, video, info;
        fs.createVideoCanvas({camera_direction:"environment", sc:URL_params.sc, maxWidth: URL_params.maxWidth, 

            callback:function() { //callback when complete

                var e = fs.get_elements();
                video = e.video;
                container = e.container;
                ctx = e.ctx;
                canvas = e.canvas;
                s_ctx = e.s_ctx;
                s_canvas = e.s_canvas;
                size = fs.get_size()

                console.log("fs initialized... size:");
                console.log(size);
                init();
            }

        });

        var lev_colors;
        var lev_colors_rgb;
        var fps = 0;
        var fps_three = 0;
        var scene, camera, renderer;
        var arrows, model, raycaster;

        var mouse = new THREE.Vector2();

        var cameras = []; // from parser.js

        function onMouseMove( event ) {

            // calculate mouse position in normalized device coordinates
            // (-1 to +1) for both components

            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;     

        }
        window.addEventListener( 'mousemove', onMouseMove, false );

        function init() {
            
            // ---=== GUI ===---

            var btn_padding = 10;
            var btn_spacing = 45;
            var btn_top = 30;

            var btn = document.createElement( 'button');
            btn.innerHTML = "FAST";
            btn.style.cssText = 'position:absolute;margin-left:10px;margin-top:' + btn_top + 'px;padding:' + btn_padding + 'px;z-index:10;white-space:nowrap';
            container.appendChild( btn );
            btn.addEventListener( "click" , 
                function() {
                    console.log("starting with " + point_count + " points : ");
                    train_pattern();
                    print_pointlist();
                    var id_start = 0;
                    if (point_count>0) id_start = point_id[point_count-1]-point_count+1;

                    for(lev = 0; lev < options_orb.num_train_levels; ++lev) {
                        for(i = 0; i < corners_num[lev]; ++i) {
                            curr_xy[point_count<<1] = pattern_corners[lev][i].x;
                            curr_xy[(point_count<<1)+1] = pattern_corners[lev][i].y;
                            point_id[point_count] = point_count + id_start;
                            if (point_count>=99) {console.log("total point count: " + point_count + " (maxed out early)"); print_pointlist();raycast_points(true);return;}
                            point_count++;
                        }
                    }
                    console.log("total point count: " + point_count);
                    print_pointlist();
                    raycast_points(true);
                }
            );
            setInterval( function () {
                if (point_count > 0) btn.innerHTML = "FAST (" + point_count + ")";
                else  btn.innerHTML = "FAST";
            }, 250);


            var btn2 = document.createElement( 'button');
            btn2.innerHTML = "FULL"; // fullscreen
            btn2.style.cssText = 'position:absolute;margin-left:10px;margin-top:' + (btn_top + btn_spacing) + 'px;padding:' + btn_padding + 'px;z-index:10;';
            container.appendChild( btn2 );
            btn2.addEventListener( "click" , function() { fs.requestFullscreen(container);} );

            var btn3 = document.createElement( 'button');
            btn3.innerHTML = "PHOTO"; // take a screenshot & send to server
            btn3.style.cssText = 'position:absolute;margin-left:10px;margin-top:' + (btn_top + 2 * btn_spacing) + 'px;padding:' + btn_padding + 'px;z-index:10;';
            container.appendChild( btn3 );
            btn3.addEventListener( "click" ,takeScreenShot );

            info = document.createElement( 'p' );
            info.style.cssText = 'position:absolute;margin-left:80px;margin-top:10px;z-index:11;width:100px';
            container.appendChild(info);

            resize_callback = function() {
                // change circle size (on canvas resize)
                options_lk.circle_radius = Math.max(1,Math.floor(size.w/250));

                info.innerHTML = "vid: " + size.vw + ", " + size.vh + "<br>" + 
                                 "can: " + size.w + ", " + size.h + "<br>" + 
                                 "s_c: " + s_canvas.width + ", " + s_canvas.height  + "<br>" ;

                renderer.setSize(window.innerWidth, window.innerHeight);

                // update the camera
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

            }
            fs.set_resizecallback( resize_callback );

            var fps_info = document.createElement( 'p' );
            fps_info.style.cssText = 'position:absolute;margin-left:8px;margin-top:5px;z-index:11;width:100px';
            container.appendChild(fps_info);
            var fps_refreshrate = 500;
            setInterval (function() {
                fps_info.innerHTML = (fps*1000/fps_refreshrate) + "/" + (fps_three*1000/fps_refreshrate);
                fps = 0;
                fps_three = 0;
            }, fps_refreshrate);

            // ---=== THREEJS INIT ===---

            // SCENE
            scene = new THREE.Scene();
            arrows = new THREE.Object3D();
            scene.add(arrows);
            model = new THREE.Object3D();
            scene.add(model);

            // CAMERA
            var SCREEN_WIDTH = window.innerWidth,
                SCREEN_HEIGHT = window.innerHeight;
            var VIEW_ANGLE = 45,
                ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT,
                NEAR = 0.1,
                FAR = 2000000;

            camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
            scene.add(camera);

            var cameraOffset = {
                x: 0,
                y: 150,
                z: 400
            };

            camera.position.set(cameraOffset.x, cameraOffset.y, cameraOffset.z);
            camera.lookAt(scene.position);

            raycaster = new THREE.Raycaster();


            // RENDERER
            var check_webgl = function() {
                try {
                    return !!window.WebGLRenderingContext && !!document.createElement('canvas').getContext('experimental-webgl');
                } catch (e) {
                    return false;
                }
            }
            if (check_webgl())
                renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true
                });
            else
                renderer = new THREE.CanvasRenderer({
                    transparent: true
                });
            renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.zIndex = 8; // below buttons, above canvii
            //renderer.setClearColor( 0xffffff, 1 );
            container.appendChild(renderer.domElement);

            // CONTROLS
            controls = new THREE.OrbitControls( camera, renderer.domElement );


            // LIGHT
            var light = new THREE.PointLight(0xffffff);
            light.position.set(100, 250, 100);
            scene.add(light);

            ///////////////////
            // AXES & ARROWS //
            ///////////////////
            axes = new THREE.Object3D();
            var dir = new THREE.Vector3(10, 0, 0);
            var origin = new THREE.Vector3(0, 0, 0);
            var length = 100;
            var hex = 0xff0000;
            var arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex);
            axes.add(arrowHelper);

            var dir = new THREE.Vector3(0, 10, 0);
            var hex = 0x00ff00;
            var arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex);
            axes.add(arrowHelper);

            var dir = new THREE.Vector3(0, 0, 10);
            var hex = 0x0000ff;
            var arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex);
            axes.add(arrowHelper);
            scene.add(axes);




            // ---=== CANVAS DATA ===---

            img_u8 = new jsfeat.matrix_t(size.vw, size.vh, jsfeat.U8_t | jsfeat.C1_t);
            // after blur
            img_u8_smooth = new jsfeat.matrix_t(size.vw, size.vh, jsfeat.U8_t | jsfeat.C1_t);


            // ---=== LKT ===---

            curr_img_pyr = new jsfeat.pyramid_t(3);
            prev_img_pyr = new jsfeat.pyramid_t(3);
            curr_img_pyr.allocate(size.vw, size.vh, jsfeat.U8_t|jsfeat.C1_t);
            prev_img_pyr.allocate(size.vw, size.vh, jsfeat.U8_t|jsfeat.C1_t);

            point_count = 0;
            point_status = new Uint8Array(100);
            prev_xy = new Float32Array(100*2);
            curr_xy = new Float32Array(100*2);
            point_id = new Uint16Array(100);

            lev_colors = ['#FFFFFF','#FF0000','#00FF00','#0000FF','#FFFF00','#222222'];
            lev_colors_rgb = [];
            lev_colors.forEach(function(c, idx) {
                lev_colors_rgb[idx] = hexToRgb(c);
            });
            console.log(lev_colors_rgb);

            function hexToRgb(hex) {
                var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16)/255,
                    g: parseInt(result[2], 16)/255,
                    b: parseInt(result[3], 16)/255
                } : null;
            }

            // we wll limit to 500 strongest points
            pattern_corners = [];
            

            resize_callback()
            tick();
            animate();
        }

        var latestCamera = false;
        document.addEventListener("keypress", function(e) {
            if (e.which == 67 || e.which == 99)  {
                if (latestCamera) setCamera(latestCamera);
                else {
                    console.log("no latestCamera");
                    if (cameras.length>0) setCamera(cameras[cameras.length-1]);
                }
            } else if (e.which == 114 || e.which == 82)  {
                raycaster.params.PointCloud.threshold++;
                console.log("new raycaster threshold = " + raycaster.params.PointCloud.threshold);
            }  else if (e.which == 83 || e.which == 115)  {
                raycast_points(true)
            }  else if (e.which == 116 || e.which == 84)  {
                raycast_points();
                
            } else {
                console.log(e.which + " pressed");
            }
        });

        function tick() {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                fps++;
                fs.drawStep();
                fs.s_drawStep();
                
                var imageData = s_ctx.getImageData(0,0, size.vw, size.vh).data;
                
                jsfeat.imgproc.grayscale(imageData, size.vw, size.vh, img_u8);
                jsfeat.imgproc.gaussian_blur(img_u8, img_u8_smooth, options_orb.blur_size|0);
                
                // swap flow data
                var _pt_xy = prev_xy;
                prev_xy = curr_xy;
                curr_xy = _pt_xy;
                var _pyr = prev_img_pyr;
                prev_img_pyr = curr_img_pyr;
                curr_img_pyr = _pyr;
                curr_img_pyr.build(img_u8, false);

                var prev_point_count = point_count;
                jsfeat.optical_flow_lk.track(prev_img_pyr, curr_img_pyr, prev_xy, curr_xy, point_count, options_lk.win_size|0, options_lk.max_iterations|0, point_status, options_lk.epsilon, options_lk.min_eigen);

                // scale for circles
                scale_w = size.w/size.vw;
                scale_h = size.h/size.vh;
                prune_oflow_points(ctx);
                if (prev_point_count != point_count && 0) {
                    console.log(prev_point_count,point_count);
                    console.log(point_status);  
                    print_pointlist(); 
                }
                
                draw_lines();
            }
            fs.requestAnimationFrame(tick);

        }


        function animate() {
            fs.requestAnimationFrame(animate);
            fps_three++;

            if (model.children.length>0) {
                raycaster.setFromCamera( mouse, camera );   

                // calculate objects intersecting the picking ray
                var intersections = raycaster.intersectObject( model.children[0]);

                if ( intersections.length  > 0 ) console.log(intersections);
                
            }

            renderer.render(scene, camera);
        }

        var points_3d = [];
        function raycast_points(serious) {

            if (serious) {
                raycaster.params.PointCloud.threshold = 9;
                setCamera(cameras[cameras.length-1]);
            }
            var n = point_count;
            var j, intersections, pos = new THREE.Vector2();
            if (!model.children[0].geometry.colors) {console.log("no pointcloud.. ");return;}
            var colorArray = model.children[0].geometry.colors;
            //console.log(colorArray);
            for(var i = 0; i < n; ++i) {                    
                if(point_status[i] == 1) {
                    var j=i<<1;
                    pos.x =  ((curr_xy[j]  /size.vw)-0.5)*(1-size.offsetW*2/window.innerWidth )*2;
                    pos.y = -((curr_xy[j+1]/size.vh)-0.5)*(1-size.offsetH*2/window.innerHeight)*2;
                    //console.log(curr_xy[j],pos.x,pos.y,curr_xy[j+1]);
                    draw_circle(ctx, (pos.x+1)*size.vw/2, (-pos.y*size.vh+1)/2, lev_colors[point_id[i]%6]);

                    raycaster.setFromCamera( pos, camera );   
                    var intersections = raycaster.intersectObjects( model.children);
                    if (intersections.length>0) {
                        if (serious) {
                            var intersect_pos = new THREE.Vector3(0,0,0);
                            var numGood = 0;
                            intersections.forEach(function(intersection, idx) {
                                intersect_pos.add(intersection.point);
                                numGood++;
                            });
                            if (numGood>0) {
                                intersect_pos.divideScalar(numGood);
                                points_3d.push({id:point_id[i],pos:model.children[0].geometry.vertices[intersections[0].index]});//intersect_pos});
                            }
                            //console.log(intersect_pos);

                        } 
                        var minDist = 50;
                        var minIdx = -1;
                        var col = lev_colors_rgb[point_id[i]%6];//lev_colors[k % 6]
                        intersections.forEach(function(i, idx) {
                            minIdx = idx;
                            colorArray[intersections[idx].index].r = col.r;
                            colorArray[intersections[idx].index].b = col.b;
                            colorArray[intersections[idx].index].g = col.g;
                        });
                        
                    }
                } 
            }
            //console.log(points_3d)
            //points_3d.forEach(function(e){console.log(e.pos)});
            model.children[0].geometry.colorsNeedUpdate = true;
        }

        function draw_lines() {
            var j = 0;
            var x1, y1, x2, y2, v = new THREE.Vector3();
            var numDrawn = 0;

            // var ray_scale = {
            //     w: 0.5*size.w*(size.w/window.innerWidth ),
            //     h: 0.5*size.h*(size.h/window.innerHeight)
            // };
            // ray_scale.offset_w = (window.innerWidth-ray_scale.w)/2;//  size.offsetW+size.w*size.offsetW*2/window.innerWidth,
            // ray_scale.offset_h = (window.innerHeight-ray_scale.h)/2;//size.offsetH+size.h*size.offsetH*2/window.innerHeight,
            var ray_scale = {
                w: 0.5*window.innerWidth,
                h: 0.5*window.innerHeight,
                offset_w:0,
                offset_h:0
            };
            for(var i = 0; i < points_3d.length; i++) {
                while (1) {
                    if ( j >= point_count || point_id[j] == points_3d[i].id) break;
                    if ( point_id[j] > points_3d[i].id ) { j=9999; break; }
                    j++;
                }
                if ((j>=point_count)) {
                    points_3d.splice(i,1);
                    i--;
                    continue;
                }
                numDrawn++;
                x1 = curr_xy[j<<1] * scale_w + size.offsetW;
                y1 = curr_xy[(j<<1)+1] * scale_h + size.offsetH;
                v.copy(points_3d[i].pos);
                v.project(camera);
                // x2 = ((v.x+1)*0.5)*(size.w)+size.offsetW;
                // y2 = ((-v.y+1)*0.5)*(size.h)+size.offsetH;
                x2 = (v.x+1)*ray_scale.w+ray_scale.offset_w;
                y2 = (-v.y+1)*ray_scale.h+ray_scale.offset_h;

                ctx.strokeStyle = lev_colors[point_id[j]%6];
                ctx.beginPath();
                ctx.moveTo(x1,y1);
                ctx.lineTo(x2,y2);
                ctx.stroke();
                j = 0;
            }
            if (numDrawn>0) console.log("numDrawn" + numDrawn);
        }


        function prune_oflow_points(ctx) {
            // remove untracked points and resize point array 
            var n = point_count;
            var i=0,j=0;
            var col;// = "#FF0000";
            for(; i < n; ++i) {                    
                if(point_status[i] == 1) {
                    if(j < i) {
                        curr_xy[j<<1] = curr_xy[i<<1];
                        curr_xy[(j<<1)+1] = curr_xy[(i<<1)+1];
                        point_id[j] = point_id[i];
                    } 
                    col = lev_colors[point_id[i]%6];//lev_colors[k % 6]
                    draw_circle(ctx, curr_xy[i<<1], curr_xy[(i<<1)+1], col);
                    ++j;
                } 
            }
            point_count = j;
        }
        function draw_circle(ctx, x, y, col) {
            ctx.fillStyle= col;
            ctx.beginPath();
            ctx.arc(x * scale_w + size.offsetW, y * scale_h + size.offsetH, options_lk.circle_radius, 0, Math.PI*2, true); 
            ctx.closePath();
            ctx.fill();
        }
        function print_pointlist() {
            console.log(point_id.subarray(0,point_count));
        }

        var img_u8, img_u8_smooth, corners_num = [];
        var pattern_corners;
        var curr_img_pyr, prev_img_pyr, point_count, point_status, prev_xy, curr_xy, point_id;

        // scale from jsfeat coordinates to display coordinates
        var scale_w, scale_h;

        var options_orb = {
            blur_size:5,
            lap_thres:30,
            eigen_thres:25,
            match_threshold:48,
            num_train_levels:1,
            max_per_level:100
        }
        var options_lk = {
            win_size:20,
            max_iterations:30,
            epsilon:0.01,
            min_eigen:0.001,
            circle_radius:4
        }

        function train_pattern() {

            // var imageData = s_ctx.getImageData(0,0, size.vw, size.vh).data;
            
            // jsfeat.imgproc.grayscale(imageData, size.vw, size.vh, img_u8);
            // jsfeat.imgproc.gaussian_blur(img_u8, img_u8_smooth, options_orb.blur_size|0);
            

            var lev=0;
            var sc = 1.0;
            var max_pattern_size = 512;
            var max_per_level = options_orb.max_per_level;
            var sc_inc = Math.sqrt(2.0); // magic number ;)
            var lev0_img = new jsfeat.matrix_t(img_u8.cols, img_u8.rows, jsfeat.U8_t | jsfeat.C1_t);
            var lev_img = new jsfeat.matrix_t(img_u8.cols, img_u8.rows, jsfeat.U8_t | jsfeat.C1_t);
            var new_width=0, new_height=0;
            var lev_corners, lev_descr;

            var sc0 = Math.min(max_pattern_size/img_u8.cols, max_pattern_size/img_u8.rows);
            new_width = (img_u8.cols*sc0)|0;
            new_height = (img_u8.rows*sc0)|0;

            jsfeat.imgproc.resample(img_u8, lev0_img, new_width, new_height);

            for(lev=0; lev < options_orb.num_train_levels; ++lev) {
                pattern_corners[lev] = [];
                lev_corners = pattern_corners[lev];

                // preallocate corners array
                var i = (new_width*new_height) >> lev;
                while(--i >= 0) {
                    lev_corners[i] = new jsfeat.keypoint_t(0,0,0,0,-1);
                }

            }

            // lets do multiple scale levels
            // we can use Canvas e.ctx draw method for faster resize 
            // but its nice to demonstrate that you can do everything with jsfeat
            for(lev = 0; lev < options_orb.num_train_levels; ++lev) {
                lev_corners = pattern_corners[lev];

                new_width = (lev0_img.cols*sc)|0;
                new_height = (lev0_img.rows*sc)|0;
                if (lev!=0) {
                    jsfeat.imgproc.resample(lev0_img, lev_img, new_width, new_height);
                    jsfeat.imgproc.gaussian_blur(lev_img, lev_img, options_orb.blur_size|0);
                } else {
                    jsfeat.imgproc.gaussian_blur(lev0_img, lev_img, options_orb.blur_size|0); // this is more robust
                }
                corners_num[lev] = detect_keypoints(lev_img, lev_corners, max_per_level);

                // fix the coordinates due to scale level
                for(var i = 0; i < corners_num[lev]; ++i) {
                    lev_corners[i].x *= 1./(sc*sc0);
                    lev_corners[i].y *= 1./(sc*sc0);
                }

                console.log("train " + lev_img.cols + "x" + lev_img.rows + " points: " + corners_num[lev]);

                sc /= sc_inc;
            }
        }

        // UTILITIES

        function detect_keypoints(img, corners, max_allowed) {

            

            jsfeat.yape06.laplacian_threshold = options_orb.lap_thres|0;
            jsfeat.yape06.min_eigen_value_threshold = options_orb.eigen_thres|0;

            // detect features
            //var count = jsfeat.yape06.detect(img, corners, 17);
            var count = jsfeat.fast_corners.detect(img, corners, 7); // last arg is border (default 3)
            console.log(count)
            // sort by score and reduce the count if needed
            if(count > max_allowed) {
                jsfeat.math.qsort(corners, 0, count-1, function(a,b){return (b.score<a.score);});
                count = max_allowed;
            }


            return count;
        }

        function getURLparams() {
            // This function is anonymous, is executed immediately and 
            // the return value is assigned to QueryString!
            var query_string = {};
            var query = window.location.search.substring(1);
            var vars = query.split("&");
            for (var i=0;i<vars.length;i++) {
                var pair = vars[i].split("=");
                if (typeof query_string[pair[0]] === "undefined") { // If first entry with this name
                    query_string[pair[0]] = decodeURIComponent(pair[1]);
                } else if (typeof query_string[pair[0]] === "string") { // If second entry with this name
                    var arr = [ query_string[pair[0]],decodeURIComponent(pair[1]) ];
                    query_string[pair[0]] = arr;
                } else { // If third or later entry with this name
                    query_string[pair[0]].push(decodeURIComponent(pair[1]));
                }
            } 
            return query_string;
        }

        // ---=== SERVER IMAGE SENDING/RECIEVING .NVM's ===---


        var uploads = [];

        function takeScreenShot() {
            // s_ctx.drawImage(video,0,0);
            var dataURL = s_canvas.toDataURL("image/jpeg",1.0);
            sendImage(dataURL);
        }


        function sendImage(dataURL) {
             
            console.log(uploads);

            if (window.XMLHttpRequest) {
                xmlhttp = new XMLHttpRequest();
            }

            var uploadid = uploads.length;
            uploads[uploadid] = {
                req: xmlhttp,
                percent: 0,
                size: dataURL.length,
                done: false
            };

            var readyState = function(uploadid, xmlhttp) {
                return function() {
                    if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
                        info.innerHTML = "xmlhttp.readyState = " + xmlhttp.readyState + ", xmlhttp.status = " + xmlhttp.status + ", responseText = " + xmlhttp.responseText;
                        var res = JSON.parse(xmlhttp.responseText);
                        if (res.success) {
                            info.innerHTML += "<br> SUCCESS!";
                            if (res.name) {
                                info.innerHTML += "<br> name : " + res.name;

                                var callback = function(success, found, result) {
                                    // console.log("name : " + name + " = res.name? : " + res.name);
                                    if (success && found && result.used == 3) {
                                        console.log("success!!!!" + result);
                                        getNVM(res.name, res.name);
                                    } else {
                                        setTimeout(function() {
                                            getJPG(res.name, callback);
                                        }, 250); // poll the server until the JPG has been processed
                                    }
                                
                                } 
                                
                                getJPG(res.name, callback(res.name));
                            }

                        }
                        else {info.innerHTML += "<br> NO SUCCESS :(";}
                        uploads[uploadid].done = true;
                    }
                }
            }
            xmlhttp.onreadystatechange = readyState(uploadid, xmlhttp); // curry the functions so they access the correct upload[uploadid]'s'
            var progress = function(uploadid) {
                return function(evt) {
                    if (evt.loaded) {
                        var percentComplete = Math.min(100, (evt.loaded / evt.total) * 100);
                        uploads[uploadid].percent = percentComplete;
                        //console.log(percentComplete);
                    }
                }
            }
            xmlhttp.onprogress = progress(uploadid); 
            xmlhttp.open("POST", "../dataURL", true);
            xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            xmlhttp.send(dataURL);
        }


        function getNVM(name, camera_name) {
            if (window.XMLHttpRequest) {
                xmlhttp = new XMLHttpRequest();
            }
            var ready = function(name, camera_name) {
                console.log("getNVM, function,  name = " + name + ", camera_name = " + camera_name)

                return function() {
                    if (xmlhttp.readyState==4 && xmlhttp.status==200) {
                        //info.innerHTML=xmlhttp.responseText;
                        if (xmlhttp.responseText.slice(0,6)=="NVM_V3") {
                            console.log("getNVM, name = " + name + ", camera_name = " + camera_name)
                            console.log("recieved (valid) NVM with camera! ");
                            arrows.children = [];
                            model.children = [];
                            cameras = readFile(xmlhttp.responseText, camera_name);
                        } else {
                            console.log("getNVM sent " + name);
                            console.log("NVM    server responded " + xmlhttp.responseText);
                        }

                    }
                }
            }
            xmlhttp.onreadystatechange = ready(name, camera_name);

            var path = "../latestNVM.nvm";
            if (name) {
                path = "../model?cam=" + name;
            } 
            console.log(path);
            xmlhttp.open("GET",path,true);
            xmlhttp.send();
        }

        function getJPG(name, callback) {
            if (window.XMLHttpRequest) {
                xmlhttp = new XMLHttpRequest();
            }
            xmlhttp.onreadystatechange=ready(name);
            function ready(name) {
                return function() {
                    if (xmlhttp.readyState==4 && xmlhttp.status==200) {
                        //info.innerHTML=xmlhttp.responseText;
                        var res = JSON.parse(xmlhttp.responseText);
                        if (callback) {
                            callback(res.success, res.found, res.result);
                        }
                        if (res.success) {
                            if (res.found) {
                                //console.log("getJPG returned " + JSON.stringify(res.result));
                                //console.log("getJPG " + name + " has used  = " + res.result.used );
                            } else {
                                console.log("getJPG " + name + " was not found ");
                            }
                        } else {
                            console.log("getJPG failed " + res);
                        }

                    }
                }
            }
            var path = "../jpgs_lookup?jpg=" + name;
            
            xmlhttp.open("GET",path,true);
            xmlhttp.send();
        }

        
        </script>
    </body>
</html>